[TIL][mmim][2022.02.14]

## 🪧 학습 내용
1. 고차함수 (map/compactMap/filter)
2. Protocol
3. class vs struct
---
### 📌1. 고차함수 (map/compactMap/filter/forEach)
1. map
- 선언
```swift 
func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]
```
- 배열 내부의 값을 하나씩 mapping -> 각 요소레 대한 값을 변경하고자 할 때 사용하고, 그 결과들을 배열의 상태로 반환한다.
```swift
let cast = ["Vivien", "Marlon", "Kim", "Karl"]
let lowercaseNames = cast.map { $0.lowercased() }
// 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]
let letterCounts = cast.map { $0.count }
// 'letterCounts' == [6, 6, 3, 4]
```
2. compactMap
- 선언
```swift
func compactMap<ElementOfResult>(_ transform: (Self.Element) throws -> ElementOfResult?) rethrows -> [ElementOfResult]
```
- 1차원 배열에서 nil을 제거하고 optional binding을 하고 싶을 때 사용
```swift
let numbers: [Int?] = [1, nil, 2, nil, 3]
let onlyNumbers = numbers.compactMap { $0 }
/// [1, 2, 3]
``` 
3. filter
- 선언
```swift 
func filter(_ isIncluded: (Self.Element) throws -> Bool) rethrows -> [Self.Element]
```
- 시퀀스의 elements가 반환된 배열에 포함되어야 하는지 여부를 나타내는 Bool값을 반환하는 클로저
- 포함되어있는 (Bool값이 ture인) elements의 배열이 반환된다.
4. forEach
- 선언
```swift
func forEach(_ body: (Element) throws -> Void) rethrows
```
- 시퀀스의 elements를 파라미터로 받는 클로저
- forEach를 사용하면 break 또는 continue 문을 사용하여 본문 클로저의 현재 호출을 종료하거나 후속 호출을 건너뛸 수 없습니다.
   - 한 마디로 모든 element를 파라미터로 받을 떄까지 동작을 멈출수 없다. 
- 또한 body 클로저에서 return 문을 사용하면 외부 범위가 아니라 본문에 대한 현재 호출에서만 종료되며 후속 호출을 건너뛰지 않습니다.
```swift
let numberWords = ["one", "two", "three"]
for word in numberWords {
    print(word)
}
// Prints "one"
// Prints "two"
// Prints "three"

numberWords.forEach { word in
    print(word)
}
// Same as above
```
---
### 📌2. Protocol
특정 역할을 하기 위한 메소드, 프로퍼티, 기타 요구사항 등의 **청사진**
#### 프로토콜의 사용
- 구조체, 클래스, 열거형은 프로토콜을 채택해서 특정 기능을 실행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있다.
- 프로토콜은 정의를 하고 제시를 할 뿐 스스로 기능을 구현하지는 않는다. (조건만 정의)
- 하나의 타입으로 사용되기 때문에 아래와 같이 타입 사용이 허용되는 모든 곳에 프로토콜을 사용할 수 있다.
> 함수, 메소드, 이니셜라이저의 파라미터 타입 혹은 리턴 타입
> 상수, 변수, 프로퍼티의 타입
> 배열, 딕셔너리의 원소타입
- 기본형태
```swift
protocol 프로토콜이름 {
 // 프로토콜 정의
}
```
- 구조체, 클래스, 열거형 등에서 프로토콜을 채택하려면 타입 이름 뒤에 콜론“:”을 붙여준 후 채택할 프로토콜 이름을 쉼표“,”로 구분하여 명시해준다. 
   - (SubClass의 경우 SuperClass를 가장 앞에 명시한다.)
```swift
struct SomeStruct: AProtocol, AnotherProtocol {
 // 구조체 정의
}
class SomeClass: SuperClass, AProtocol, AnotherProtocol {
 // 클래스 정의
}
```
---
### 📌3. class vs struct
#### 공통점
- 값을 저장할 프로퍼티를 선언할 수 있습니다.
- 함수적 기능을 하는 메서드를 선언 할 수 있습니다.
- 내부 값에. 을 사용하여 접근할 수 있습니다.
- 생성자를 사용해 초기 상태를 설정할 수 있습니다.
- extension을 사용하여 기능을 확장할 수 있습니다.
- Protocol을 채택하여 기능을 설정할 수 있습니다.
#### 차이점
- class
   - 참조 타입입니다.
   - ARC로 메모리를 관리합니다.
   - 같은 클래스 인스턴스를 여러 개의 변수에 할당한 뒤 값을 변경시키면 할당한 모든 변수에 영향을 줍니다. (메모리만 복사)
   - 상속이 가능합니다.
   - 타입 캐스팅을 통해 런타임에서 클래스 인스턴스의 타입을 확인할 수 있습니다.
   - deinit을 사용하여 클래스 인스턴스의 메모리 할당을 해제할 수 있습니다.
- struct
   - 값 타입입니다.
   - 구조체 변수를 새로운 변수에 할당할 때마다 새로운 구조체가 할당됩니다.
   - 즉 같은 구조체를 여러 개의 변수에 할당한 뒤 값을 변경시키더라도 다른 변수에 영향을 주지 않습니다. (값 자체를 복사)




